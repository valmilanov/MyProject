---
title: "GLDM3001: Module 8 - Exercises"
author: "YOUR_NAME"
date: '`r Sys.Date()`'
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
## nov 17
## 12.1 clustering
## 12.1.1 hierarchical clustering
## 12.1.2 k means
## final project will be assigned nov 18, simulate data for models due nov22
## supervised model that can beat with more accuracy
```

### Load some packages

```{r packages, echo = FALSE, message = FALSE, warning = FALSE}
library(ggplot2)
library(tidyverse)
library(dplyr)
library(graphics)
library(mdsr) 
library(utils)
library(fs)
library(rgdal)

```

## Using unsupervised learning for vehicle clustering

Use the `readxl` package to read the file `2016 FEGuide.xlsx` into `R`, just as we did during the module session. Clean up some of the resulting variable names, select a small subset of the variables, and filter for distinct models of **Toyota** vehicles. The resulting data set contains information about `75` different models that Toyota produces.

Next, we use the `readxl` package to read this file into `R`, clean up some of the resulting variable names, select a small subset of the variables, and filter for distinct models of **Toyota** vehicles. The resulting data set contains information about `75` different models that Toyota produces.

> Store the data file "2016 FEGuide.xlsx" in a subfolder by the name 'data' in your working directory.

**Note:** You may need to adjust the code below to specify the "2016 FEGuide.xlsx" file location if you opt out to store the data file in different location.

#### Read the data into data frame by running the code

```{r prepare data}
# load the readxl package to read the xlsx file in R
library(readxl)

# set the working directory to the current one, where you downloaded the file
# work_dir <- getwd()
# setwd(work_dir)

filename <- fs::dir_ls("16data", regexp = "public\\.xlsx") %>% head(1)

# use read_excel function to read the file by creating the full path to it, using paste0 function.


cars <- read_excel(filename) %>%
  janitor::clean_names() %>%
  dplyr::select(
    make = mfr_name,
    model = carline,
    displacement = eng_displ,
    number_cyl,
    number_gears,
    city_mpg = city_fe_guide_conventional_fuel,
    hwy_mpg = hwy_fe_guide_conventional_fuel
  ) %>%
  distinct(model, .keep_all = TRUE) %>%
  filter(make == "General Motors") 

# have a look at the data
glimpse(cars)

```

**Exercise 1:** Modify the code above or write new code to choose the car maker `General Motors`. How many records (rows) are in the data?

```{r ex1}
nrow(cars)

```

**Exercise 2:** Run the code below to see the first vehicle in `cars`. What is the model?

```{r ex2}

cars[1, ] ## corvette

```

**Exercise 3:** Write code to find out how many **different** models of `General Motors` vehicles are in the `cars` data frame.

```{r ex3}
length(unique(cars$model)) ## 79 models of cars 

```

**Exercise 4:** The code below uses `dist()` function to provide the distance from each individual car to every other car. Add code to obtain the class of the `car_diffs` and the `car_mat` objects.

```{r ex4, warning = FALSE}

car_diffs <- cars %>%
  column_to_rownames(var = "model") %>% #  convert the second column from cars (model) to row names (from tibble package) 
  dist() 


# convert the dist object to matrix
car_mat <- car_diffs %>% 
  as.matrix()

car_mat[1:6, 1:6] %>% # try 10 instead of 6
  round(digits = 2)

class(car_diffs)
class(car_mat)


```

**Exercise 5:** The code below produces the `phylo` tree. Adjust the `cex` parameter in `plot()` to improve readability of the labels as much as possible.

```{r ex5, warning = FALSE}

library(ape) 
car_diffs %>% 
  hclust() %>% 
  as.phylo() %>% 
  plot(cex = 0.2, label.offset = .4) # adjust the cex to better visualize

```

**Exercise 6:** The code below choose 4,000 biggest cities, from the data `world_cities` in the world and their longitudes and latitudes to a data frame called `big_cities`. Add code to find out how many cities were left out of the total available in the `world_cities` data.

```{r ex6}
big_cities <- world_cities %>% 
  arrange(desc(population)) %>%
  head(4000) %>%
  dplyr::select(longitude, latitude, name)
glimpse(world_cities)
glimpse(big_cities)


```

```{r}

# 
# ## I need the complement set of the cities world_cities - big_cities
# big1 <- unique(big_cities$name, rm.na = TRUE)
# length(big1)
# world1 <- unique(world_cities$name, rm.na = TRUE)
# length(world1)
# head(big1, n=10)
# head(world1, n=10)
# 
# ## remove the big1 from world1
# leftOut <-length(world1) - length(big1) ; leftOut
# 
# ## number of cities left out is 415, causes NA errors in kmeans below
```

**Exercise 7:** Run the `k-means` clustering algorithm code to separate these `4,000` points---each of which is located in a two-dimensional plane---into `k=6` clusters based on their locations alone.

Re-run the code for `centers = 3,4,5,7,8`. Which cluster appear to persist based on coloration?

```{r ex7}

set.seed(15)
# install the package first if not installed
#install.packages("mclust")
library(mclust) 

# form 6 cluster iteratively
city_clusts <- big_cities %>%  ##
  kmeans(centers = 6, nstart =10) %>% 
  fitted("classes") %>% 
  as.character()

# form 6 cluster iteratively, by forming initially 10 random sets
km <- kmeans(big_cities, centers = 6, nstart = 10) 

# inspect the structure of the kmeans output cluster object
str(km)

# access two important features of cluster, their size and centers
km$size
km$centers



# add a variable to record the cluster to which a point belongs to
big_cities <- big_cities %>% 
  mutate(cluster = city_clusts)

# graph the clusters, using the cluster variable to pick the color
big_cities %>% 
  ggplot(aes(x = longitude, y = latitude)) +
  geom_point(aes(color = cluster), alpha = 0.5)  + 
  scale_color_brewer(palette = "Set3")

```

**Exercise 8:** The code below uses the **EPSG:4326** (WGS84) CRS and runs `K-means` algorithm on the `big_cities` data and visualizes the results.

```{r}
library(rgdal)

# assign the big_cities data.frame to a working data.frame object df 
df <- big_cities 

# create spatial object from d
coordinates(df) <- 1:2

# Set WGS 84 (EPSG:4326) standard for projecting longitude latitude coordinates
proj4string(df) <- CRS("+init=epsg:4326")

# coordinate reference system using the EPSG:4326 standard
CRS.new <- CRS("+init=epsg:4326") ## proj4string is adding CRS to the df

# the d object in the new CRS, you may print out few records to see how it looks in the new CRS
df.new <- spTransform(df, CRS.new)
head(df.new)

# just for information review the 
proj4string(df.new) %>% strwrap() ## wraps character strings to format paragraphs


# form 6 cluster iteratively
city_clusts <- as.data.frame(df.new) %>%
kmeans(centers = 6) %>% fitted("classes") %>% as.character()

# add a variable for the newly formed clusters
df.new <- as.data.frame(df.new) %>% mutate(cluster = city_clusts) 

# graph the clusters, using the cluster variable to pick the color
df.new %>% ggplot(aes(x = longitude, y = latitude)) +
geom_point(aes(color = cluster), alpha = 0.5) +
scale_color_brewer(palette = "Set3")


```

**Exercise 9:** Modify the code from **Exercise 8** to produce run runs `K-means` algorithm on the `big_cities` data and visualizes the results in **EPSG:4269** (NAD83) CRS.

```{r}

# erase
# Set NAD83 (EPSG:4269) standard for projecting longitude latitude coordinates
proj4string(df) <- CRS("+init=epsg:4269")

# coordinate reference system using the EPSG:4326 standard
CRS.new <- CRS("+init=epsg:4269")

# the d object in the new CRS, you may print out few records to see how it looks in the new CRS
df.new <- spTransform(df, CRS.new)

# just for information review the 
proj4string(df.new) %>% strwrap()


# form 6 cluster iteratively
city_clusts <- as.data.frame(df.new) %>%
kmeans(centers = 6) %>% fitted("classes") %>% as.character()

# add a variable for the newly formed clusters
df.new <- as.data.frame(df.new) %>% mutate(cluster = city_clusts) 

# graph the clusters, using the cluster variable to pick the color
df.new %>% ggplot(aes(x = longitude, y = latitude)) +
geom_point(aes(color = cluster), alpha = 0.5) +
scale_color_brewer(palette = "Set3")
## 4326 and 4369 are very similar in this dataset

```

**Exercise 10:** Compare how the cluster differ across the different choice of CRS.
